# Руководство разработчика - Document Scanner

## Содержание
1. [Введение](#введение)
2. [Структура проекта](#структура-проекта)
3. [Установка и запуск](#установка-и-запуск)
4. [Архитектура приложения](#архитектура-приложения)
5. [Компоненты](#компоненты)
6. [Утилиты и алгоритмы](#утилиты-и-алгоритмы)
7. [Поток данных](#поток-данных)

---

## Введение

Document Scanner - это веб-приложение для сканирования и обработки документов. Оно позволяет:
- Автоматически определять границы документа на фотографии
- Выравнивать перспективу документа
- Применять различные фильтры для улучшения качества
- Сохранять результат в PNG, JPG или PDF

### Технологии
- **React** - библиотека для создания пользовательского интерфейса
- **OpenCV.js** - библиотека для обработки изображений (загружается динамически)
- **Canvas API** - для работы с пикселями изображений
- **Vite** - инструмент сборки проекта

---

## Структура проекта

```
scaner/
├── src/
│   ├── components/          # React компоненты
│   │   ├── ImageUploader.jsx      # Загрузка изображения
│   │   ├── CornerEditor.jsx       # Редактирование углов документа
│   │   ├── ImageFilters.jsx      # Панель фильтров
│   │   ├── CanvasViewer.jsx       # Просмотр результата
│   │   ├── DownloadButton.jsx     # Кнопки скачивания
│   │   └── LoadingOverlay.jsx     # Индикатор загрузки
│   ├── utils/              # Утилиты и алгоритмы
│   │   ├── cornerDetection.js     # Определение углов документа
│   │   ├── perspectiveTransform.js # Перспективная трансформация
│   │   └── imageProcessing.js     # Обработка изображений
│   ├── App.jsx             # Главный компонент
│   └── main.jsx            # Точка входа
├── package.json
└── vite.config.js
```

---

## Установка и запуск

### Требования
- Node.js версии 16 или выше
- npm или yarn

### Установка зависимостей
```bash
npm install
```

### Запуск в режиме разработки
```bash
npm run dev
```

Приложение откроется по адресу `http://localhost:5173`

### Сборка для продакшена
```bash
npm run build
```

---

## Архитектура приложения

Приложение работает в три этапа:

1. **Загрузка** (`step === 'upload'`)
   - Пользователь загружает изображение
   - Создается URL для отображения

2. **Определение углов** (`step === 'corners'`)
   - Автоматическое определение углов документа
   - Возможность ручной корректировки
   - Применение перспективной трансформации

3. **Применение фильтров** (`step === 'filters'`)
   - Просмотр результата
   - Настройка фильтров
   - Сохранение в файл

### Управление состоянием

Приложение использует локальное состояние React (useState). Главный компонент `App.jsx` хранит:
- `image` - файл изображения
- `imageUrl` - URL для отображения
- `corners` - координаты углов документа
- `processedImage` - обработанное изображение (Canvas)
- `filters` - настройки фильтров
- `step` - текущий этап обработки

---

## Компоненты

### ImageUploader

**Назначение:** Загрузка изображения через drag-and-drop или выбор файла.

**Использует:** `react-dropzone` для удобной загрузки файлов.

**Основные функции:**
- Принимает файлы изображений (JPG, PNG, WebP)
- Ограничение размера: 10MB
- Вызывает `onImageUpload` с выбранным файлом

**Как работает:**
```javascript
// Когда файл загружен, создается URL для отображения
const url = URL.createObjectURL(file)
onImageUpload(file) // Передает файл в App.jsx
```

---

### CornerEditor

**Назначение:** Определение и редактирование углов документа.

**Основные функции:**
- Автоматическое определение углов через OpenCV.js
- Ручное редактирование углов (перетаскивание)
- Предпросмотр результата трансформации
- Применение перспективной трансформации

**Как работает:**

1. **Автоматическое определение углов:**
   ```javascript
   detectCornersAutomatically()
   ```
   - Загружает OpenCV.js (если еще не загружен)
   - Вызывает `detectCorners()` из `cornerDetection.js`
   - Если OpenCV недоступен, использует `detectCornersSimple()`

2. **Отображение углов:**
   - Рисует изображение на canvas
   - Рисует линии между углами
   - Рисует круги в местах углов

3. **Редактирование углов:**
   - При клике на угол начинается перетаскивание
   - При движении мыши обновляются координаты угла
   - Предпросмотр обновляется автоматически

4. **Применение трансформации:**
   - Вычисляет оптимальные размеры выходного изображения
   - Применяет перспективную трансформацию
   - Передает результат в `App.jsx`

**Важные функции:**

- `loadOpenCV()` - загружает OpenCV.js из CDN
- `drawCanvas()` - рисует изображение и углы на canvas
- `updatePreview()` - обновляет предпросмотр трансформации
- `handleApplyTransform()` - применяет финальную трансформацию

---

### ImageFilters

**Назначение:** Панель управления фильтрами изображения.

**Доступные фильтры:**
- Яркость (-100 до +100)
- Контраст (-100 до +100)
- Резкость (0 до 200)
- Насыщенность (-100 до +100)
- Шумоподавление (0 до 100)
- Температура цвета (-100 до +100)
- Оттенок (-100 до +100)
- Бинаризация (0 до 100)
- Белый фон (0 до 100)
- Улучшение текста (0 до 100)

**Как работает:**

1. **Локальное состояние:**
   - Хранит текущие значения фильтров
   - Обновляет UI сразу для плавности

2. **Debounce:**
   - Применяет фильтры с задержкой 300ms после остановки слайдера
   - Предотвращает лишние вычисления

3. **Готовые пресеты:**
   - "Авто-улучшение" - базовые настройки
   - "Режим документа" - оптимальные настройки для текста
   - "Сброс" - все фильтры в 0

---

### CanvasViewer

**Назначение:** Отображение обработанного изображения с применением фильтров.

**Как работает:**

1. Получает `processedImage` (Canvas) и `filters`
2. Извлекает ImageData из Canvas
3. Применяет все фильтры через `applyAllFilters()`
4. Отображает результат на canvas

**Переключение оригинал/обработанное:**
- Показывает либо оригинальное изображение, либо обработанное с фильтрами

---

### DownloadButton

**Назначение:** Сохранение результата в различных форматах.

**Форматы:**
- PNG - без потерь качества
- JPG - сжатие с качеством 95%
- PDF - через jsPDF библиотеку

**Как работает:**

1. Создает временный canvas
2. Применяет фильтры к изображению
3. Конвертирует в нужный формат
4. Скачивает файл через `file-saver`

---

## Утилиты и алгоритмы

### cornerDetection.js

#### detectCorners()

**Назначение:** Автоматическое определение углов белого документа на изображении.

**Алгоритм работы:**

1. **Подготовка изображения:**
   ```javascript
   // Конвертация в grayscale (оттенки серого)
   cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)
   
   // Размытие для уменьшения шума
   cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0)
   ```

2. **Пороговая обработка:**
   ```javascript
   // Метод Оцу автоматически определяет оптимальный порог
   cv.threshold(blurred, thresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU)
   ```
   - Разделяет изображение на белое (документ) и черное (фон)
   - Метод Оцу находит порог, который лучше всего разделяет два класса

3. **Морфологические операции:**
   ```javascript
   // Opening - удаляет мелкие шумы
   cv.morphologyEx(thresh, morphed, cv.MORPH_OPEN, kernel, ...)
   
   // Closing - заполняет небольшие разрывы
   cv.morphologyEx(morphed, closed, cv.MORPH_CLOSE, kernel, ...)
   ```
   - Очищает изображение от артефактов
   - Соединяет разорванные линии

4. **Поиск контуров:**
   ```javascript
   cv.findContours(closed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
   ```
   - Находит все контуры (границы) на изображении
   - `RETR_EXTERNAL` - только внешние контуры
   - `CHAIN_APPROX_SIMPLE` - упрощенное представление контура

5. **Выбор наибольшего контура:**
   - Находит контур с наибольшей площадью (предположительно документ)
   - Фильтрует контуры меньше 10% от площади изображения

6. **Аппроксимация до четырехугольника:**
   ```javascript
   cv.approxPolyDP(bestContour, approx, epsilon, true)
   ```
   - Упрощает контур до многоугольника
   - `epsilon` - точность аппроксимации (2% от периметра)

7. **Обработка количества точек:**
   - Если точек > 4: выбирает 4 наиболее удаленные через `selectFourCorners()`
   - Если точек < 4: дополняет углами изображения

8. **Сортировка углов:**
   - Сортирует по углу относительно центра
   - Находит верхний левый угол (минимальная сумма x+y)
   - Переставляет так, чтобы порядок был: верхний-левый, верхний-правый, нижний-правый, нижний-левый

#### selectFourCorners()

**Назначение:** Выбирает 4 наиболее удаленные точки из массива точек.

**Алгоритм:**

1. Находит центр всех точек
2. Разделяет точки на 4 квадранта:
   - Квадрант 0: x < center.x, y < center.y (верхний-левый)
   - Квадрант 1: x >= center.x, y < center.y (верхний-правый)
   - Квадрант 2: x >= center.x, y >= center.y (нижний-правый)
   - Квадрант 3: x < center.x, y >= center.y (нижний-левый)
3. Из каждого квадранта выбирает точку, наиболее удаленную от центра
4. Если квадрант пуст, выбирает ближайшую точку к углу изображения

#### detectCornersSimple()

**Назначение:** Альтернативный метод без OpenCV (использует Canvas API).

**Алгоритм:**

1. **Пороговая обработка:**
   - Вычисляет среднюю яркость изображения
   - Порог = средняя яркость + 30 (но не больше 200)
   - Создает бинарное изображение (белое/черное)

2. **Сканирование границ:**
   - Сканирует изображение с 4 сторон
   - Ищет первую строку/столбец с достаточным количеством белых пикселей (30%)
   - Находит границы документа

3. **Формирование углов:**
   - Использует найденные границы для создания 4 углов
   - Добавляет небольшой отступ (margin)

---

### perspectiveTransform.js

#### calculateOptimalOutputSize()

**Назначение:** Вычисляет оптимальные размеры выходного изображения.

**Алгоритм:**

1. Вычисляет длины сторон четырехугольника:
   - Верхняя сторона: расстояние между углами 0 и 1
   - Нижняя сторона: расстояние между углами 3 и 2
   - Левая сторона: расстояние между углами 0 и 3
   - Правая сторона: расстояние между углами 1 и 2

2. Использует средние значения:
   - `avgWidth = (topWidth + bottomWidth) / 2`
   - `avgHeight = (leftHeight + rightHeight) / 2`

3. Добавляет 1% запас для предотвращения обрезки

4. Устанавливает минимальный размер 100px

#### transformPerspectiveCanvas()

**Назначение:** Применяет перспективную трансформацию к изображению.

**Что такое перспективная трансформация?**

Когда вы фотографируете документ под углом, он выглядит искаженным (трапеция вместо прямоугольника). Перспективная трансформация "выпрямляет" документ, делая его прямоугольным.

**Алгоритм:**

1. **Создание выходного canvas:**
   ```javascript
   const canvas = document.createElement('canvas')
   canvas.width = outputWidth
   canvas.height = outputHeight
   ```

2. **Обратное преобразование:**
   Для каждого пикселя выходного изображения:
   - Вычисляем, какой пиксель исходного изображения ему соответствует
   - Используем билинейную интерполяцию для плавности

3. **Билинейная интерполяция:**
   ```javascript
   function bilinearInterpolation(topLeft, topRight, bottomLeft, bottomRight, u, v)
   ```
   - `u, v` - нормализованные координаты (0-1)
   - Интерполирует значение между 4 соседними пикселями
   - Обеспечивает плавное изображение без пикселизации

4. **inversePerspectiveTransform():**
   - Преобразует координаты из выходного изображения в исходное
   - Использует билинейную интерполяцию углов для вычисления позиции

**Пример:**
```
Исходное изображение (искаженное):
    A ---- B
   /        \
  /          \
 D ---------- C

Выходное изображение (выпрямленное):
A' ---- B'
|        |
|        |
D' ---- C'
```

Для пикселя в позиции (x, y) выходного изображения:
1. Нормализуем: u = x/width, v = y/height
2. Вычисляем соответствующую позицию в исходном:
   - srcX = интерполяция между A.x, B.x, D.x, C.x
   - srcY = интерполяция между A.y, B.y, D.y, C.y
3. Берем пиксель из исходного изображения (с интерполяцией)

---

### imageProcessing.js

#### applyBrightness()

**Алгоритм:**
```javascript
newValue = oldValue + (factor * 255)
```
- `factor = value / 100` (от -1 до +1)
- Ограничивает значения от 0 до 255

#### applyContrast()

**Алгоритм:**
```javascript
factor = (259 * (value + 255)) / (255 * (259 - value))
newValue = factor * (oldValue - 128) + 128
```
- Центрирует значения вокруг 128 (середина)
- Увеличивает разницу между светлыми и темными областями

#### applySharpness()

**Алгоритм Unsharp Mask:**

1. Вычисляет лапласиан (вторую производную):
   ```javascript
   laplacian = -center + (top + bottom + left + right) / 4
   ```
   - Показывает, насколько пиксель отличается от соседей
   - Большие значения = резкие границы

2. Применяет:
   ```javascript
   newValue = oldValue + strength * laplacian
   ```
   - Усиливает границы (делает их более контрастными)

#### applySaturation()

**Алгоритм:**

1. Вычисляет grayscale (оттенок серого):
   ```javascript
   gray = 0.299 * R + 0.587 * G + 0.114 * B
   ```

2. Смешивает оригинальный цвет с grayscale:
   ```javascript
   newColor = gray + (originalColor - gray) * (1 + factor)
   ```
   - `factor > 0` - увеличивает насыщенность
   - `factor < 0` - уменьшает насыщенность (ближе к grayscale)

#### applyDenoise()

**Алгоритм медианного фильтра:**

1. Для каждого пикселя:
   - Собирает значения соседних пикселей в окрестности (радиус зависит от значения)
   - Сортирует значения
   - Берет медиану (среднее значение)

2. Медиана устойчива к выбросам (шум), поэтому эффективно убирает шум

#### applyBinarization()

**Алгоритм Оцу (Otsu's method):**

1. **Построение гистограммы:**
   - Подсчитывает количество пикселей каждого оттенка серого (0-255)

2. **Поиск оптимального порога:**
   - Перебирает все возможные пороги (0-255)
   - Для каждого порога вычисляет дисперсию между двумя классами (белое/черное)
   - Выбирает порог с максимальной дисперсией

3. **Применение:**
   - Пиксели выше порога → белые (255)
   - Пиксели ниже порога → черные (0)
   - Смешивает с оригиналом в зависимости от силы фильтра

#### applyWhiteBackground()

**Алгоритм:**

1. **Определение порога фона:**
   - Строит гистограмму яркости
   - Находит порог, при котором накапливается 10% самых ярких пикселей
   - Это предположительно фон документа

2. **Осветление фона:**
   - Для пикселей близких к фону (выше 80% порога)
   - Вычисляет коэффициент осветления
   - Увеличивает яркость пропорционально силе фильтра

#### applyTextEnhancement()

**Алгоритм адаптивного улучшения:**

1. **Анализ локальных областей:**
   - Разбивает изображение на блоки
   - Вычисляет среднюю яркость каждого блока
   - Использует разреженную сетку (каждый N-й пиксель) для производительности

2. **Интерполяция:**
   - Для каждого пикселя находит ближайшие вычисленные средние
   - Использует билинейную интерполяцию для получения локального среднего

3. **Усиление контраста:**
   - Если пиксель сильно отличается от локального среднего (текст):
     - Усиливает контраст
   - Если пиксель близок к среднему (фон):
     - Слегка осветляет

#### applyAllFilters()

**Порядок применения:**

1. Базовые фильтры (яркость, контраст, резкость, насыщенность, шумоподавление)
2. Коррекция цвета (температура, оттенок)
3. Специальные фильтры для документов (белый фон, улучшение текста, бинаризация)

**Важно:** Порядок имеет значение! Базовые фильтры применяются первыми, специальные - последними.

---

## Поток данных

### 1. Загрузка изображения

```
Пользователь → ImageUploader → App.jsx
                              ↓
                         imageUrl создан
                         step = 'corners'
```

### 2. Определение углов

```
App.jsx → CornerEditor
         ↓
    detectCornersAutomatically()
         ↓
    cornerDetection.detectCorners()
         ↓
    OpenCV обработка
         ↓
    corners определены
         ↓
    CornerEditor отображает углы
         ↓
    Пользователь может редактировать
         ↓
    handleApplyTransform()
         ↓
    perspectiveTransform.transformPerspectiveCanvas()
         ↓
    processedImage (Canvas) создан
         ↓
    App.jsx получает processedImage
         ↓
    step = 'filters'
```

### 3. Применение фильтров

```
App.jsx → CanvasViewer
         ↓
    Получает processedImage и filters
         ↓
    imageProcessing.applyAllFilters()
         ↓
    Применяет все фильтры последовательно
         ↓
    Отображает результат на canvas
```

### 4. Сохранение

```
Пользователь → DownloadButton
             ↓
        prepareCanvas()
             ↓
        Применяет фильтры
             ↓
        Конвертирует в формат (PNG/JPG/PDF)
             ↓
        Скачивает файл
```

---

## Полезные советы

### Отладка

1. **Откройте DevTools (F12)**
   - Console - для просмотра ошибок
   - Network - для проверки загрузки OpenCV.js
   - Sources - для отладки кода

2. **Проверка состояния:**
   ```javascript
   // В компоненте добавьте console.log
   console.log('corners:', corners)
   console.log('filters:', filters)
   ```

3. **Проверка изображения:**
   ```javascript
   // Проверьте размеры canvas
   console.log('canvas size:', canvas.width, canvas.height)
   ```

### Производительность

1. **Большие изображения:**
   - Обработка может быть медленной для изображений > 2000px
   - Рассмотрите уменьшение размера перед обработкой

2. **Debounce фильтров:**
   - Фильтры применяются с задержкой 300ms
   - Не изменяйте это значение без необходимости

3. **OpenCV.js:**
   - Загружается только при необходимости
   - Размер библиотеки ~8MB

### Расширение функциональности

1. **Добавление нового фильтра:**
   - Создайте функцию в `imageProcessing.js`
   - Добавьте слайдер в `ImageFilters.jsx`
   - Добавьте в `applyAllFilters()`

2. **Изменение алгоритма определения углов:**
   - Модифицируйте `detectCorners()` в `cornerDetection.js`
   - Можно изменить параметры морфологических операций
   - Можно изменить метод пороговой обработки

3. **Добавление нового формата экспорта:**
   - Модифицируйте `DownloadButton.jsx`
   - Добавьте новую функцию обработки

---

## Часто задаваемые вопросы

**Q: Почему OpenCV.js загружается так долго?**
A: Библиотека большая (~8MB). Загружается из CDN при первом использовании. Можно предзагрузить или использовать локальную копию.

**Q: Как работает билинейная интерполяция?**
A: Это метод плавного вычисления значения между 4 точками. Используется для получения плавного изображения при трансформации.

**Q: Почему фильтры применяются в определенном порядке?**
A: Порядок важен для качества результата. Базовые фильтры (яркость, контраст) должны применяться первыми, специальные (бинаризация) - последними.

**Q: Как работает метод Оцу?**
A: Метод автоматически находит оптимальный порог для разделения изображения на два класса (белое/черное), максимизируя дисперсию между классами.

**Q: Можно ли использовать без OpenCV.js?**
A: Да, есть fallback метод `detectCornersSimple()`, но он менее точный.

---

## Полезные ссылки

- [React документация](https://react.dev/)
- [OpenCV.js документация](https://docs.opencv.org/4.8.0/d5/d10/tutorial_js_root.html)
- [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)
- [ImageData API](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)

---

## Контакты и поддержка

Если у вас возникли вопросы или проблемы:
1. Проверьте консоль браузера на наличие ошибок
2. Убедитесь, что все зависимости установлены
3. Проверьте версию Node.js (должна быть >= 16)

---

*Документация обновлена: 2024*

